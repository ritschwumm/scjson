package scjson.converter

import scala.deriving.Mirror
import scala.compiletime.*

import scutil.lang._
import scutil.lang.TupleNApplySyntax._
import scutil.lang.tc.ApplicativeTupleNSyntax._
import scjson.ast._

import scjson.converter.{
	TupleConverters	=> TC,
	JsonConverters	=> JC,
	UnitConverters	=> UC
}

trait CaseJsonReaders extends UnitJsonReaders {
	def coReader[T](value:T):JsonReader[T]	=
		UC.UnitReader map constant(value)

	def cc0Reader[S](apply:()=>S):JsonReader[S]	=
		JC.expectObjectMap	>=>
		Converter { map =>
			if (map.isEmpty)	Validated valid apply()
			else				Validated invalid JsonError(s"expected zero elements, got ${map.size.toString}")
		}

	[#inline def cc1AutoReader[S](using m:Mirror.ProductOf[S], [#f1:JsonReader[Tuple.Elem[m.MirroredElemTypes, 0]]#,]):JsonReader[S]	= {
		JC.expectObjectMap	>=>
		TC.mapToTuple1[String,JsonValue](
			[#constValue[Tuple.Elem[m.MirroredElemLabels,0] & String]#,
			]
		)	>=>
		Converter { values =>
			Tuple1(
				[#f1.convert#,
				]
			)
			.applyN(values)
			.zipN
			.map(m.fromProduct)
		}
	}#

	]
}
