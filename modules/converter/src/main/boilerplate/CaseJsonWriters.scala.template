package scjson.converter

import scala.deriving.Mirror
import scala.compiletime.*

import scutil.lang._
import scutil.lang.TupleNApplySyntax._
import scutil.lang.tc.ApplicativeTupleNSyntax._
import scjson.ast._

import scjson.converter.{
	TupleConverters	=> TC,
	JsonConverters	=> JC,
	UnitConverters	=> UC,
}

trait CaseJsonWriters extends UnitJsonWriters {
	def coWriter[T](value:T):JsonWriter[T]	=
		UC.UnitWriter contraMap constant(())

	def cc0Writer[S](unapply:S=>Boolean):JsonWriter[S]	=
		Converter.total[JsonError,S,Unit] { it =>
			if (!unapply(it)) sys error "expected total unapply"
		} >=>
		Converter.constant[JsonError,Unit,Map[String,JsonValue]](Map.empty)	>=>
		JC.makeObjectMap

	[#inline def cc1AutoWriter[S<:Product](using m:Mirror.ProductOf[S], ev:m.MirroredElemTypes <:< Tuple1[[#?#]], [#f1:JsonWriter[Tuple.Elem[m.MirroredElemTypes, 0]]#,]):JsonWriter[S]	= {
		// TODO this sucks, but scala is not smart enough to find out
		// i'm manually doing a Map[MirroredElemTypes,JsonWriter]
		// and this type is identical to m.MirroredElemTypes
		type Values	=
			Tuple1[
				[#Tuple.Elem[m.MirroredElemTypes, 0]#,
				]
			]

		Converter.total[JsonError,S,m.MirroredElemTypes] { (s:S) =>
			Tuple.fromProductTyped(s)(using m)
		} >=>
		Converter { (values:m.MirroredElemTypes) =>
			Tuple1(
				[#f1.convert#,
				]
			)
			.applyN(values.asInstanceOf[Values])
			.zipN
		} >=>
		TC.tuple1ToMap[JsonError,String,JsonValue](
			[#constValue[Tuple.Elem[m.MirroredElemLabels,0] & String]#,
			]
		)	>=>
		JC.makeObjectMap
	}#

	]
}
